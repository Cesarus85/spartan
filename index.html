<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Block-Halo – Clean (Light Shadows, no Bloom)</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #hud{position:absolute;left:12px;bottom:12px;color:#eee;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:8px;font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;z-index:10}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="hud"><b>Block-Halo</b><br>LS: Laufen · RS: Drehen · A: Springen · <b>LT: Schießen</b></div>
<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';

/*** === SWITCHES === ***/
const LIGHT_SHADOWS = true;  // Boden empfängt Schatten, Spieler/Arme/Waffe werfen

/*** === RENDERER/SCENE === ***/
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
renderer.xr.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.06;
if (LIGHT_SHADOWS){
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
}
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x98cfff, 34, 150);

// sehr naher Near-Clip, damit Arme/Waffe nah am HMD nicht weggeschnitten werden
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.02, 1200);

/*** === LIGHTING === ***/
const hemi = new THREE.HemisphereLight(0xbfdfff, 0x2a3a44, 0.7);
scene.add(hemi);
const sun = new THREE.DirectionalLight(0xffffff, 0.75);
sun.position.set(120, 220, 60);
if (LIGHT_SHADOWS){
  sun.castShadow = true;
  sun.shadow.mapSize.set(1024,1024);
  sun.shadow.camera.near = 1; sun.shadow.camera.far = 600;
  sun.shadow.camera.left = -120; sun.shadow.camera.right = 120;
  sun.shadow.camera.top = 120; sun.shadow.camera.bottom = -120;
}
scene.add(sun);

/*** === PLAYER RIG === ***/
const player = new THREE.Group();
player.add(camera);
scene.add(player);
player.position.set(0, 1.0, 0);

/*** === SKY + HALO RING === ***/
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(1000, 32, 16),
  new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      top: {value:new THREE.Color(0x7fc3ff)},
      bottom:{value:new THREE.Color(0xcfeaff)},
      offset:{value:420}, exponent:{value:0.9}
    },
    vertexShader: `
      varying vec3 vW;
      void main(){ vec4 p=modelMatrix*vec4(position,1.0); vW=p.xyz;
        gl_Position=projectionMatrix*viewMatrix*p; }`,
    fragmentShader: `
      varying vec3 vW; uniform vec3 top,bottom; uniform float offset,exponent;
      void main(){ float h=normalize(vW+vec3(0.,offset,0.)).y;
        float f=max(pow(max(h,0.0),exponent),0.0);
        gl_FragColor=vec4(mix(bottom,top,f),1.0); }`
  })
);
scene.add(sky);

const ring = new THREE.Mesh(
  new THREE.TorusGeometry(450, 10, 24, 128),
  new THREE.MeshPhongMaterial({ color:0xc9e6ff, emissive:0x254d66, emissiveIntensity:0.3, shininess:60 })
);
ring.rotation.x = Math.PI*0.15;
ring.rotation.z = Math.PI*0.07;
ring.position.set(-60, 250, -80);
scene.add(ring);

/*** === TINY PIXEL TEXTURES (subtil) === ***/
function makePixelTex(pixelsFn){
  const s = 8;
  const cnv = document.createElement('canvas'); cnv.width = cnv.height = s;
  const ctx = cnv.getContext('2d', { willReadFrequently:true });
  const img = ctx.createImageData(s, s);
  for (let y=0;y<s;y++){
    for (let x=0;x<s;x++){
      const [r,g,b,a] = pixelsFn(x,y,s);
      const i = (y*s+x)*4;
      img.data[i]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=a;
    }
  }
  ctx.putImageData(img,0,0);
  const tex = new THREE.CanvasTexture(cnv);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestMipMapLinearFilter;
  tex.anisotropy = 4;
  return tex;
}
const texGrass = makePixelTex((x,y,s)=>{
  const base=[74,166,74]; const shade = ((x+y)&1)? 10:-6; return [base[0]+shade, base[1]+shade, base[2]+shade, 255];
});
const texDirt  = makePixelTex((x,y,s)=>{
  const base=[122,86,50]; const shade = (x%3===0||y%3===0)? -12:6; return [base[0]+shade, base[1]+shade, base[2]+shade, 255];
});
const texRock  = makePixelTex((x,y,s)=>{
  const base=[123,138,143]; const n = ((x*13+y*7)%5)-2; return [base[0]+n, base[1]+n, base[2]+n, 255];
});
const texSteel = makePixelTex((x,y,s)=>{
  const base=[102,127,140]; const n = ((x+y)&1)? 8:-4; return [base[0]+n, base[1]+n, base[2]+n, 255];
});

/*** === MATERIALS & GEO === ***/
const BLOCK = 0.75;
const gBlock = new THREE.BoxGeometry(BLOCK, BLOCK, BLOCK);
const mGrass  = new THREE.MeshStandardMaterial({ map:texGrass, roughness:0.92, metalness:0.0 });
const mDirt   = new THREE.MeshStandardMaterial({ map:texDirt,  roughness:0.98, metalness:0.0 });
const mRock   = new THREE.MeshStandardMaterial({ map:texRock,  roughness:0.9,  metalness:0.04 });
const mSteel  = new THREE.MeshStandardMaterial({ map:texSteel, roughness:0.62, metalness:0.55 });
const mAccent = new THREE.MeshStandardMaterial({ color:0x2ec5ff, emissive:0x0a3d4e, emissiveIntensity:0.9, metalness:0.9, roughness:0.18 });
[mGrass,mDirt,mRock,mSteel].forEach(m=>{ m.map.repeat.set(1.5,1.5); });

/*** === INSTANCER === ***/
class Instancer {
  constructor(geo, mat, cap=50000){
    this.mesh = new THREE.InstancedMesh(geo, mat, cap);
    this.count = 0;
  }
  add(x,y,z){ this.mesh.setMatrixAt(this.count++, new THREE.Matrix4().makeTranslation(x,y,z)); }
  finalize(scene){
    this.mesh.instanceMatrix.needsUpdate = true;
    this.mesh.count = this.count;
    // keine Schatten auf tausenden Blöcken
    this.mesh.castShadow = false;
    this.mesh.receiveShadow = false;
    scene.add(this.mesh);
  }
}
const iGrass = new Instancer(gBlock, mGrass);
const iDirt  = new Instancer(gBlock, mDirt);
const iRock  = new Instancer(gBlock, mRock);
const iSteel = new Instancer(gBlock, mSteel);
const iAccent= new Instancer(gBlock, mAccent);
const instancedWorld = [];

/*** === TERRAIN (HEIGHTMAP) === ***/
const radiusX = 48, radiusZ = 64;
const sizeX = radiusX*2+1, sizeZ = radiusZ*2+1;
const heightMap = new Int16Array(sizeX*sizeZ);
const idx = (ix,iz)=> (iz+radiusZ)*sizeX + (ix+radiusX);
function heightAt(ix,iz){
  const nx = ix / radiusX, nz = iz / radiusZ;
  const d = Math.sqrt(nx*nx + nz*nz);
  if (d > 1.0) return 0;
  const rim = Math.max(0, 1.0 - d);
  const hill = Math.pow(rim, 1.5) * 8;
  const cx = (ix*BLOCK), cz = (iz*BLOCK);
  const flat = Math.max(0, 1.0 - (Math.hypot(cx,cz)/(BLOCK*18)));
  const plateau = flat * 4.5;
  const wav = (Math.sin(ix*0.35)+Math.cos(iz*0.29))*0.8 + Math.sin((ix+iz)*0.18)*0.6;
  return Math.max(Math.floor(hill*0.5 + plateau + wav), 1);
}
// Bodenplatte (empfängt Schatten)
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(1000,1000),
  new THREE.MeshStandardMaterial({ color:0x2f5f33, roughness:1, metalness:0 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y = -BLOCK*0.5;
ground.receiveShadow = LIGHT_SHADOWS;
scene.add(ground);

// Insel instanzieren
for (let ix=-radiusX; ix<=radiusX; ix++){
  for (let iz=-radiusZ; iz<=radiusZ; iz++){
    const h = heightAt(ix,iz);
    heightMap[idx(ix,iz)] = h;
    for (let y=0; y<h; y++){
      const mat = (y===h-1) ? iGrass : (y>=h-3 ? iDirt : iRock);
      mat.add(ix*BLOCK, y*BLOCK, iz*BLOCK);
    }
  }
}
iGrass.finalize(scene); iDirt.finalize(scene); iRock.finalize(scene);
instancedWorld.push(iGrass.mesh, iDirt.mesh, iRock.mesh);

/*** === FORTRESS === ***/
const F = { w: 22, d: 22, h: 14, baseY: 1, doorW:4, doorH:6 };
const halfW = Math.floor(F.w/2), halfD = Math.floor(F.d/2);
// Fundament
for (let x=-halfW; x<halfW; x++){
  for (let z=-halfD; z<halfD; z++){
    iRock.add(x*BLOCK, (F.baseY-1)*BLOCK, z*BLOCK);
  }
}
// Mauern + Innenboden
for (let y=0; y<F.h; y++){
  for (let x=-halfW; x<halfW; x++){
    for (let z=-halfD; z<halfD; z++){
      const isEdge = (x===-halfW || x===halfW-1 || z===-halfD || z===halfD-1);
      const isDoor = (z===0 && x>=-F.doorW/2 && x<F.doorW/2 && y<F.doorH);
      if (isEdge && !isDoor){
        const matSel = (y%6===0) ? iAccent : iSteel;
        matSel.add(x*BLOCK, (F.baseY+y)*BLOCK, z*BLOCK);
      } else if (y===0) {
        iRock.add(x*BLOCK, (F.baseY+y)*BLOCK, z*BLOCK);
      }
    }
  }
}
// Zinnen
for (let x=-halfW; x<halfW; x+=2){
  iSteel.add(x*BLOCK, (F.baseY+F.h)*BLOCK, -halfD*BLOCK);
  iSteel.add(x*BLOCK, (F.baseY+F.h)*BLOCK, (halfD-1)*BLOCK);
}
for (let z=-halfD; z<halfD; z+=2){
  iSteel.add(-halfW*BLOCK, (F.baseY+F.h)*BLOCK, z*BLOCK);
  iSteel.add((halfW-1)*BLOCK, (F.baseY+F.h)*BLOCK, z*BLOCK);
}
// Innentreppe
for (let i=0; i<F.h-2; i++){
  iSteel.add((-halfW+2)*BLOCK, (F.baseY+1+i)*BLOCK, (-halfD+3+i)*BLOCK);
}
// Akzente
for (let y=1; y<F.h-1; y+=3){
  iAccent.add((-halfW+4)*BLOCK, (F.baseY+y)*BLOCK, 0);
  iAccent.add((halfW-5)*BLOCK,   (F.baseY+y)*BLOCK, 0);
}
iSteel.finalize(scene); iAccent.finalize(scene);
instancedWorld.push(iSteel.mesh, iAccent.mesh);

/*** === HEIGHT QUERY & SIMPLE COLLISION === ***/
function groundHeightAt(x,z){
  const ix = Math.round(x / BLOCK);
  const iz = Math.round(z / BLOCK);
  if (ix<-radiusX || ix>radiusX || iz<-radiusZ || iz>radiusZ) return -BLOCK*0.5;
  return (heightMap[idx(ix,iz)] - 0.5) * BLOCK;
}
function inFortressAABB(x,z){
  const minX = (-halfW)*BLOCK, maxX=(halfW-1)*BLOCK;
  const minZ = (-halfD)*BLOCK, maxZ=(halfD-1)*BLOCK;
  return x>=minX && x<=maxX && z>=minZ && z<=maxZ;
}
function doorway(x,z){
  const minX = (-F.doorW/2)*BLOCK, maxX = (F.doorW/2-1)*BLOCK;
  return (x>=minX && x<=maxX && Math.abs(z) < BLOCK*1.1);
}
function isBlockedXZ(x,z){
  if (!inFortressAABB(x,z)) return false;
  if (doorway(x,z)) return false;
  const edgeTol = BLOCK*0.9;
  const minX = (-halfW)*BLOCK, maxX=(halfW-1)*BLOCK;
  const minZ = (-halfD)*BLOCK, maxZ=(halfD-1)*BLOCK;
  const nearEdge = Math.min(Math.abs(x-minX), Math.abs(x-maxX), Math.abs(z-minZ), Math.abs(z-maxZ)) < edgeTol;
  return nearEdge;
}

/*** === VISIBLE BODY & CONTROLLERS === ***/
function makeSpartanBody(){
  const g = new THREE.Group(); g.frustumCulled=false; g.renderOrder = 1;
  const torso = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.32,0.18), new THREE.MeshStandardMaterial({ color:0x2b3a43, metalness:0.5, roughness:0.4 }));
  const chest = new THREE.Mesh(new THREE.BoxGeometry(0.30,0.10,0.22), mSteel);
  chest.position.set(0,0.12,0.0);
  const belt  = new THREE.Mesh(new THREE.BoxGeometry(0.30,0.08,0.18), mAccent);
  belt.position.set(0,-0.16,0.01);
  const pelvis= new THREE.Mesh(new THREE.BoxGeometry(0.26,0.12,0.20), mSteel);
  pelvis.position.set(0,-0.28,0.02);
  ;[torso,chest,belt,pelvis].forEach(m=>{ m.castShadow = LIGHT_SHADOWS; });
  g.add(torso,chest,belt,pelvis);
  return g;
}
const bodyAnchor = new THREE.Group();
camera.add(bodyAnchor);
// leicht nach vorne/unten, sonst Near-Clip
bodyAnchor.position.set(0,-0.55,-0.25);
bodyAnchor.add(makeSpartanBody());

// Controller-Objekte
const controller0 = renderer.xr.getController(0);
const controller1 = renderer.xr.getController(1);
scene.add(controller0, controller1);

function makeLeftArmWithGun(){
  const group = new THREE.Group(); group.frustumCulled=false; group.renderOrder = 2;
  const forearm = new THREE.Mesh(new THREE.BoxGeometry(0.10,0.10,0.22), new THREE.MeshStandardMaterial({ color:0x556b78, metalness:0.4, roughness:0.5 }));
  forearm.position.set(0,-0.02,-0.08);
  const plate = new THREE.Mesh(new THREE.BoxGeometry(0.11,0.05,0.14), mAccent);
  plate.position.set(0,-0.02,-0.02);
  const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.08,0.26), new THREE.MeshStandardMaterial({ color:0x2f3940, metalness:0.75, roughness:0.3 }));
  gunBody.position.set(0.05,0.00,-0.20);
  const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.012,0.012,0.18,10), new THREE.MeshStandardMaterial({ color:0x444, metalness:0.9, roughness:0.2 }));
  barrel.rotation.x = Math.PI/2; barrel.position.set(0.05,0.00,-0.34);
  const sight = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.02,0.07), mAccent);
  sight.position.set(0.05,0.04,-0.20);
  ;[forearm,plate,gunBody,barrel,sight].forEach(m=>{ m.castShadow = LIGHT_SHADOWS; });
  group.add(forearm,plate,gunBody,barrel,sight);
  group.rotation.y = 0.15;  // natürlicher Winkel
  group.position.z = -0.05; // etwas nach vorne
  return group;
}
function makeRightHand(){
  const h = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.03,0.12), mSteel);
  h.position.set(0,-0.02,-0.05); h.frustumCulled=false; h.renderOrder=2;
  h.castShadow = LIGHT_SHADOWS;
  return h;
}
function clearChildren(obj){ while(obj.children.length) obj.remove(obj.children[0]); }

// „connected“ → Hände/Arme sicher anhängen (egal ob Index 0 oder 1)
[controller0, controller1].forEach(ctrl=>{
  ctrl.addEventListener('connected', (e)=>{
    const handed = e.data?.handedness || e.data?.profiles?.[0] || '';
    clearChildren(ctrl);
    if (handed === 'left')  ctrl.add(makeLeftArmWithGun());
    else if (handed === 'right') ctrl.add(makeRightHand());
    else ctrl.add(makeRightHand()); // Fallback
    ctrl.position.z -= 0.02; // leicht nach vorne, gegen Clipping
  });
});

// Failsafe: falls „connected“ nicht feuert
renderer.xr.addEventListener('sessionstart', ()=>{
  setTimeout(()=>{
    if (controller0.children.length===0 && controller1.children.length===0){
      controller0.add(makeLeftArmWithGun());
      controller1.add(makeRightHand());
    }
  }, 800);
});

/*** === MOVEMENT / PHYSICS === ***/
const moveSpeed = 0.10, rotationSpeed = 0.05, jumpSpeed = 0.30, gravity = 0.01;
let isJumping=false, jumpVel=0;

function updateJump(){
  const gh = groundHeightAt(player.position.x, player.position.z);
  const target = gh + 1.0;
  if (isJumping){
    const ny = player.position.y + jumpVel;
    jumpVel -= gravity;
    if (ny > target){ player.position.y = ny; }
    else { isJumping=false; jumpVel=0; player.position.y = target; }
  } else {
    player.position.y += Math.sign(target - player.position.y) * Math.min(Math.abs(target-player.position.y), 0.08);
  }
}

/*** === SHOOTING (Hitscan) === ***/
const raycaster = new THREE.Raycaster();
let leftTriggerDown=false, lastShot=0;
function muzzlePose(ctrl){
  const m = new THREE.Matrix4().copy(ctrl.matrixWorld);
  const origin = new THREE.Vector3().setFromMatrixPosition(m);
  const dir = new THREE.Vector3(0,0,-1).applyMatrix4(new THREE.Matrix4().extractRotation(m)).normalize();
  const muzzle = origin.clone().add(dir.clone().multiplyScalar(0.24));
  return {origin:muzzle, dir};
}
function shoot(){
  const now = performance.now();
  if (now - lastShot < 140) return;
  lastShot = now;

  // Controller mit Waffe (falls Index-Swap): nimm den, der den linken Arm trägt
  const gunCtrl = controller0.children.length && controller0.children[0].children?.length ? controller0 :
                  controller1.children.length ? controller1 : controller0;
  const {origin, dir} = muzzlePose(gunCtrl);
  raycaster.set(origin, dir);
  const hits = raycaster.intersectObjects(instancedWorld, false);
  if (hits.length){ spawnImpact(hits[0].point); }

  // kurzer sichtbarer Bolt
  const bolt = new THREE.Mesh(new THREE.CylinderGeometry(0.01,0.01,0.22,8),
    new THREE.MeshStandardMaterial({ color:0x7fe8ff, emissive:0x2ec5ff, emissiveIntensity:1.3, metalness:0.1, roughness:0.2 })
  );
  bolt.rotation.x = Math.PI/2;
  const boltEnd = origin.clone().addScaledVector(dir, 0.5);
  bolt.position.copy(origin);
  scene.add(bolt);
  const t0 = performance.now();
  (function tick(){
    const t = performance.now()-t0;
    bolt.position.lerp(boltEnd, Math.min(1, t/80));
    if (t<90) requestAnimationFrame(tick); else scene.remove(bolt);
  })();

  // Mündungsblitz (ohne Bloom)
  const flash = new THREE.Mesh(new THREE.SphereGeometry(0.03,12,10), new THREE.MeshBasicMaterial({ color:0x9df0ff }));
  flash.position.copy(origin);
  scene.add(flash);
  setTimeout(()=>{ scene.remove(flash); }, 60);
}
function spawnImpact(p){
  const s = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,6), new THREE.MeshBasicMaterial({ color:0x9df0ff }));
  s.position.copy(p);
  scene.add(s);
  setTimeout(()=>{ scene.remove(s); }, 100);
}

/*** === INPUT === ***/
function handleInput(){
  const session = renderer.xr.getSession();
  if (!session){ updateJump(); return; }

  for (const source of session.inputSources){
    if (!source.gamepad) continue;
    const a = source.gamepad.axes, b = source.gamepad.buttons, hand = source.handedness;

    if (hand==='left'){
      const xAxis=a[2]||0, yAxis=a[3]||0, dz=0.12;
      if (Math.abs(xAxis)>dz || Math.abs(yAxis)>dz){
        const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion); fwd.y=0; fwd.normalize();
        const right= new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion); right.y=0; right.normalize();
        const tryPos = player.position.clone().addScaledVector(fwd, -yAxis*moveSpeed).addScaledVector(right, xAxis*moveSpeed);
        if (!isBlockedXZ(tryPos.x, tryPos.z)){ player.position.x = tryPos.x; player.position.z = tryPos.z; }
      }
      // Trigger kann je nach Gerät b[0] oder b[1] sein → robust prüfen
      const trig = !!(b[0]?.pressed || b[1]?.pressed);
      if (trig && !leftTriggerDown){ leftTriggerDown=true; shoot(); }
      if (!trig) leftTriggerDown=false;
    }

    if (hand==='right'){
      const xAxis = a[2]||0, dz=0.12;
      if (Math.abs(xAxis)>dz) player.rotation.y -= xAxis*rotationSpeed;
      if (b[4]?.pressed && !isJumping){ isJumping=true; jumpVel=jumpSpeed; }
    }
  }
  updateJump();
}

/*** === LOOP === ***/
let last = performance.now();
renderer.setAnimationLoop(()=>{
  const now = performance.now(); const dt = now-last; last=now;
  handleInput();
  renderer.render(scene, camera);
});

/*** === RESIZE === ***/
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/*** === START POSITION === ***/
player.position.set(0, 1.0, 18*BLOCK);
player.rotation.y = Math.PI; // Blick zur Festung
</script>
</body>
</html>
